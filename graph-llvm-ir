#!/usr/bin/env python
import sys

from llvm.core import *
import llvm


USE_CLUSTERS = 1
CLUSTER_EDGES = 1
INV_NODES = 1


tmp_i = 1
def number_tmps(mod):
    """This function establishes explicit names for nameless numeric
    temporaries in IR. It also should give human-readable IDs to each
    statement in IR. Actually, as this is SSA, it uses result temporary
    name as an ID for statement. And fails here, because void-typed
    statements do not allow to set temporary name. So, this needs rework,
    and so far worked around during graph construction.
    """
    global tmp_i
    for f in mod.functions:
#        print `f`
        for b in f.basic_blocks:
#            print "BB name:", b.name
            for i in b.instructions:
#                print i
                if not i.name and i.type != Type.void():
                    i.name = "t%d" % tmp_i
                    tmp_i += 1


class Graph:

    def __init__(self, f, out):
        self.edges = []
        self.f = f
        self.out = out
        self.anon_bblock_cnt = 0
        self.void_instr_cnt = 0

    def write(self, line=""):
        self.out.write(line + "\n")

    def start_graph(self):
        self.write("digraph G {")
        self.write("compound=true")
        self.write('label="Black edges - dataflow, red edges - control flow"')

    def edge(self, fro, to, extra=""):
        self.edges.append("%s -> %s%s" % (fro, to, extra))

    def block_name(self, b):
        """Returns basic block name, i.e. its entry label, or made name
        if label if absent."""
        if b.name:
            return b.name
        self.anon_bblock_cnt += 1
        return "unk_block_%d" % self.anon_bblock_cnt

    def instr_name(self, i):
        """Returns instruction name, for which result variable name is used.
        If result variable name is absent (void statement), make up name.
        """
        n = i.name
        if not n:
            self.void_instr_cnt += 1
            n = "_%d" % self.void_instr_cnt
        return n

    def declare_clusters(self):
        if USE_CLUSTERS:
            # Pre-allocate label nodes to subgraphs, otherwise Graphviz puts them to wrong subgraphs
                for b in self.f.basic_blocks:
                    name = self.block_name(b)
                    if not INV_NODES:
                        self.write("subgraph cluster_%s {" % name)
                    if not CLUSTER_EDGES:
                        self.write('%s [label="label: %s"]' % (name, name))
                    elif INV_NODES:
                        self.write('%s [shape=point height=0.02 width=0.02 color=red fixedsize=true]' % name)
                    if not INV_NODES:
                        self.write("}")
                self.write()


    def render(self):
#        print `f`
        self.start_graph()
        self.declare_clusters()
        lab = 1
        for b in self.f.basic_blocks:
            block_name = self.block_name(b)
            self.edges = []
            if USE_CLUSTERS:
                self.write("subgraph cluster_%s {" % block_name)
                self.write("label=%s" % block_name)
            if not CLUSTER_EDGES:
                self.write('%s [label="label: %s"]' % (block_name, block_name))
#           elif INV_NODES:
#               self.write('%s [shape=point]' % (b.name))

            # Create block entry label node and edge from it to first IR instruction
            if not CLUSTER_EDGES or INV_NODES:
                attr = "[color=red]"
                if b.name == "entry":
                    attr += "[weight=5]"
                if CLUSTER_EDGES:
                    attr += "[lhead=cluster_%s]" % block_name
                self.edge(block_name, b.instructions[0].name, attr)

            last_inst_name = None
            for i in b.instructions:
                n = self.instr_name(i)
                self.write('%s [label="%s"]' % (n, i))
                if i.opcode_name == "br" and len(i.operands) == 1:
                    self.edge(last_inst_name, n, "[color=red]")

                for a in i.operands:
                        if isinstance(a, Constant) and not a.name:
                            arg_val = '"%s"' % a
                        else:
                            arg_val = a.name
                        if i.opcode_name == "br" and type(a) is BasicBlock:
                            # For jump targets, we jump from current node to label (arg)
                            if CLUSTER_EDGES and not INV_NODES:
                                arg_val = a.instructions[0].name
                            attrs = "[color=red]"
                            if CLUSTER_EDGES:
                                attrs += "[color=red][lhead=cluster_%s][arrowhead=none]" % a.name
                            self.edge(n, arg_val, attrs)
                        else:
                            # For data, flow is from opearnd to operation
                            self.edge(arg_val, n)
                last_inst_name = n
            if USE_CLUSTERS:
                self.write("}")
            for e in self.edges:
                self.write(e)
            self.write()
        self.write("}")


if __name__ == "__main__":
    with open(sys.argv[1]) as asm:
        mod = Module.from_assembly(asm)

    number_tmps(mod)

    for f in mod.functions:
        if not f.is_declaration:
            print "Writing %s.dot" % f.name
            with open(f.name + ".dot", "w") as out:
                g = Graph(f, out)
                g.render()
